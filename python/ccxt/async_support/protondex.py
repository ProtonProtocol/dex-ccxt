# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
from ccxt.abstract.protondex import ImplicitAPI
import hashlib
import math
from ccxt.base.types import OrderSide
from typing import Optional
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import OrderNotFound
from ccxt.base.decimal_to_precision import TICK_SIZE
from ccxt.base.precise import Precise


class protondex(Exchange, ImplicitAPI):

    def describe(self):
        return self.deep_extend(super(protondex, self).describe(), {
            'id': 'protondex',
            'name': 'protondex',
            'countries': ['US'],
            'rateLimit': 600,
            'version': 'v1',
            'has': {
                'CORS': None,
                'spot': True,
                'margin': False,
                'swap': False,
                'future': False,
                'option': False,
                'addMargin': False,
                'cancelOrder': True,
                'createOrder': True,
                'createReduceOnlyOrder': False,
                'createStopLimitOrder': False,
                'createStopMarketOrder': False,
                'createStopOrder': False,
                'fetchBalance': True,
                'fetchBorrowRate': False,
                'fetchBorrowRateHistories': False,
                'fetchBorrowRateHistory': False,
                'fetchBorrowRates': False,
                'fetchBorrowRatesPerSymbol': False,
                'fetchCurrencies': False,
                'fetchDepositAddress': False,
                'fetchDepositAddresses': False,
                'fetchDeposits': True,
                'fetchFundingHistory': False,
                'fetchFundingRate': False,
                'fetchFundingRateHistory': False,
                'fetchFundingRates': False,
                'fetchIndexOHLCV': False,
                'fetchL2OrderBook': False,
                'fetchLeverage': False,
                'fetchLeverageTiers': False,
                'fetchMarginMode': False,
                'fetchMarkets': True,
                'fetchMarkOHLCV': False,
                'fetchMyTrades': True,
                'fetchOHLCV': True,
                'fetchOpenInterestHistory': False,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchOrders': True,
                'fetchPosition': False,
                'fetchPositionMode': False,
                'fetchPositions': False,
                'fetchPositionsRisk': False,
                'fetchPremiumIndexOHLCV': False,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTrades': True,
                'fetchTradinFee': False,
                'fetchTradingFees': True,
                'fetchTransfer': False,
                'fetchTransfers': False,
                'fetchWithdrawals': False,
                'reduceMargin': False,
                'setLeverage': False,
                'setMarginMode': False,
                'setPositionMode': False,
                'transfer': False,
                'withdraw': False,
            },
            'hostname': 'https://mainnet.api.protondex.com',
            'urls': {
                'logo': 'https://protonswap.com/img/logo.svg',
                'api': {
                    'rest': 'https://mainnet.api.protondex.com/dex',
                    'public': 'https://mainnet.api.protondex.com/dex',
                    'private': 'https://mainnet.api.protondex.com/dex',
                },
                'test': {
                    'rest': 'https://testnet.api.protondex.com/dex',
                    'public': 'https://testnet.api.protondex.com/dex',
                    'private': 'https://testnet.api.protondex.com/dex',
                },
                'www': 'https://protondex.com/',
                'doc': [
                    'https://www.docs.protondex.com',
                ],
                'fees': [
                    'https://www.docs.protondex.com/dex/what-is-proton-dex/dex-fees-and-discounts',
                ],
                'referral': 'https://protondex.com/',
            },
            'api': {
                'public': {
                    'get': [
                        'markets/all',
                        'orders/open',  # ?{account}/{marketid}/{offset}/{limit}'
                        'orders/history',  # ?{account}/{marketid}/{offset}/{limit}'
                        'orders/lifecycle',  # ?{orderid}'
                        'orders/depth',  # ?{marketid}/{step}/{limit}'
                        'trades/daily',
                        'trades/history',  # ?{account}/{symbol}/{offset}/{ordinal_order_ids}/{limit}'
                        'trades/recent',  # ?{marketid}/{offset}/{limit}'
                        'chart/ohlcv',  # ?{interval}/{dateFrom}/{dateTo}/{marketid}/{limit}'
                        'status/sync',
                        'account/balances',  # ?{account}'
                    ],
                    'post': [
                        'orders/serialize',  # application/json - transaction
                        'orders/submit',  # application/json - serilized_tx_hex, signatures
                    ],
                },
                'private': {
                    'post': [
                    ],
                    'get': [
                        'user/fees',
                        'account/deposits',
                        'account/withdrawals',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'tierBased': True,
                    'maker': 0.001,  # tiered fee discounts
                    'taker': 0.001,  # tiered fee discounts
                },
            },
            'precision': {
                'amount': self.parse_number('0.00000001'),
                'price': self.parse_number('0.00000001'),
            },
            'precisionMode': TICK_SIZE,
        })

    async def fetch_markets(self, params={}):
        """
        retrieves data on all markets for protondex
        :param dict params: extra parameters specific to the exchange api endpoint
        :returns [dict]: an array of objects representing market data
        """
        response = await self.publicGetMarketsAll(params)
        #
        #    {
        #        "data": [
        #            {
        #                "name": "ETH-BTC",
        #                "precision": 6,
        #                "min_volume": "0.00000001",
        #                "min_price": "0.000001",
        #                "volume": "0.015713",
        #                "last_price": "0.069322",
        #                "highest_bid": "0.063892",
        #                "lowest_ask": "0.071437",
        #                "change_in_24h": "2.85",
        #                "size_precision": 8,
        #                "price_precision": 6
        #            },
        #            ...
        #        ]
        #    }
        #
        markets = self.safe_value(response, 'data', [])
        result = []
        for i in range(0, len(markets)):
            market = markets[i]
            baseId, quoteId = market['symbol'].split('_')
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            result.append({
                'id': market['symbol'],
                'symbol': market['symbol'],
                'base': base,
                'quote': quote,
                'settle': None,
                'baseId': baseId,
                'quoteId': quoteId,
                'settleId': None,
                'type': 'spot',
                'spot': True,
                'margin': False,
                'swap': False,
                'future': False,
                'option': False,
                'active': True,
                'contract': False,
                'linear': None,
                'inverse': None,
                'contractSize': None,
                'expiry': None,
                'expiryDatetime': None,
                'strike': None,
                'optionType': None,
                'precision': {
                    'amount': self.parse_number(self.parse_precision(self.safe_string(market, 'size_precision'))),
                    'price': self.parse_number(self.parse_precision(self.safe_string(market, 'price_precision'))),
                },
                'limits': {
                    'leverage': {
                        'min': None,
                        'max': None,
                    },
                    'amount': {
                        'min': self.safe_number(market, 'minPrice'),
                        'max': None,
                    },
                    'price': {
                        'min': self.safe_number(market, 'minVolume'),
                        'max': None,
                    },
                    'cost': {
                        'min': None,
                        'max': None,
                    },
                },
                'info': market,
            })
        return result

    def parse_ticker(self, ticker, market=None):
        #
        #     {
        #         "name":"ETH-BTC",
        #         "precision":6,
        #         "min_volume":"0.00000001",
        #         "min_price":"0.000001",
        #         "volume":"0.000452",
        #         "last_price":"0.079059",
        #         "highest_bid":"0.073472",
        #         "lowest_ask":"0.079059",
        #         "change_in_24h":"8.9",
        #         "size_precision":8,
        #         "price_precision":6
        #     }
        #
        marketId = self.safe_string(ticker, 'name')
        market = self.safe_market(marketId, market, '-')
        timestamp = self.milliseconds()
        last = self.safe_string(ticker, 'last_price')
        return self.safe_ticker({
            'symbol': ticker['symbol'],
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_string(ticker, 'high'),
            'low': self.safe_string(ticker, 'low'),
            'bid': self.safe_string(ticker, 'highest_bid'),
            'bidVolume': self.safe_string(ticker, 'volume_bid'),
            'ask': self.safe_string(ticker, 'lowest_ask'),
            'askVolume': self.safe_string(ticker, 'volume_ask'),
            'vwap': None,
            'open': self.safe_string(ticker, 'open'),
            'close': self.safe_string(ticker, 'close'),
            'last': last,
            'previousClose': None,
            'change': None,
            'percentage': self.safe_string(ticker, 'change_percentage'),
            'average': None,
            'baseVolume': None,
            'quoteVolume': self.safe_string(ticker, 'volume'),
            'info': ticker,
        }, market)

    async def fetch_ticker(self, symbol, params={}):
        """
        fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        :param str symbol: unified symbol of the market to fetch the ticker for
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns dict: a `ticker structure <https://docs.ccxt.com/en/latest/manual.html#ticker-structure>`
        """
        await self.load_markets()
        tickers = await self.fetch_tickers()
        return tickers[symbol]

    async def fetch_tickers(self, symbols=None, params={}):
        """
        fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
        :param [str]|None symbols: unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns dict: an array of `ticker structures <https://docs.ccxt.com/en/latest/manual.html#ticker-structure>`
        """
        await self.load_markets()
        symbols = self.market_symbols(symbols)
        response = await self.publicGetTradesDaily(params)
        #
        #     {
        #         "data":[
        #             {
        #                 "name":"ETH-BTC",
        #                 "precision":6,
        #                 "min_volume":"0.00000001",
        #                 "min_price":"0.000001",
        #                 "volume":"0.000452",
        #                 "last_price":"0.079059",
        #                 "highest_bid":"0.073472",
        #                 "lowest_ask":"0.079059",
        #                 "change_in_24h":"8.9",
        #                 "size_precision":8,
        #                 "price_precision":6
        #             }
        #         ]
        #     }
        #
        tickers = self.safe_value(response, 'data', [])
        result = {}
        for i in range(0, len(tickers)):
            ticker = self.parse_ticker(tickers[i])
            symbol = ticker['symbol']
            result[symbol] = ticker
        return self.filter_by_array(result, 'symbol', symbols)

    async def fetch_order_book(self, symbol, limit=None, params={}):
        """
        fetches information on open orders with bid(buy) and ask(sell) prices, volumes and other data
        :param str symbol: unified symbol of the market to fetch the order book for
        :param int|None limit: the maximum amount of order book entries to return
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns dict: A dictionary of `order book structures <https://docs.ccxt.com/en/latest/manual.html#order-book-structure>` indexed by market symbols
        """
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['symbol'],
        }
        request['limit'] = limit if (limit is not None) else 100
        request['step'] = params['step'] if (params['step'] is not None) else 100
        response = await self.publicGetOrdersDepth(self.extend(request, params))
        data = self.safe_value(response, 'data', {})
        return self.parse_order_book(data, market['symbol'], None, 'bids', 'asks', 'bid', 'ask')

    def parse_trade(self, trade, market=None):
        #
        # fetchTrades(public)
        #
        #      {
        #          "id":"5ec36295-5c8d-4874-8d66-2609d4938557",
        #          "price":"4050.06","size":"0.0044",
        #          "market_name":"ETH-USDT",
        #          "side":"sell",
        #          "created_at":"2021-12-07T17:47:36.811000Z"
        #      }
        #
        # fetchMyTrades(private)
        #
        #      {
        #              "id": "0718d520-c796-4061-a16b-915cd13f20c6",
        #              "price": "0.00000358",
        #              "size": "50.0",
        #              "market_name": "DOGE-BTC",
        #              "order_id": "ff2616d8-58d4-40fd-87ae-937c73eb6f1c",
        #              "side": "buy",
        #              "fee': "0.00000036",
        #              "fee_currency_code": "btc",
        #              "liquidity": "T",
        #              "created_at": "2021-12-08T18:26:33.840000Z"
        #      }
        #
        timestamp = self.parse8601(self.safe_string(trade, 'block_time'))
        tradeId = self.safe_string(trade, 'trade_id')
        priceString = self.safe_string(trade, 'price')
        orderSide = self.safe_string(trade, 'order_side')
        account = self.safe_string(trade, 'account')
        amountString = account == self.safe_string(trade, 'bid_amount') if self.safe_string(trade, 'bid_user') else self.safe_string(trade, 'ask_amount')
        orderId = account == self.safe_string(trade, 'bid_user_order_id') if self.safe_string(trade, 'bid_user') else self.safe_string(trade, 'ask_user_order_id')
        feeString = account == self.safe_string(trade, 'bid_fee') if self.safe_string(trade, 'bid_user') else self.safe_string(trade, 'ask_fee')
        feeCurrencyId = account == self.safe_string(market, 'baseId') if self.safe_string(trade, 'bid_user') else self.safe_string(market, 'quoteId')
        fee = None
        if feeString is not None:
            feeCurrencyCode = self.safe_currency_code(feeCurrencyId)
            fee = {
                'cost': feeString,
                'currency': feeCurrencyCode,
            }
        return self.safe_trade({
            'info': trade,
            'id': tradeId,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': market['symbol'],
            'order': orderId,
            'type': None,
            'side': orderSide,
            'takerOrMaker': None,
            'price': priceString,
            'amount': amountString,
            'cost': None,
            'fee': fee,
        }, market)

    def parse_trades(self, trades, market: Optional[object] = None, since: Optional[int] = None, limit: Optional[int] = None, params={}):
        trades = self.to_array(trades)
        result = []
        for i in range(0, len(trades)):
            trades[i]['account'] = params['account']
            trade = self.extend(self.parse_trade(trades[i], market))
            result.append(trade)
        return result

    async def fetch_my_trades(self, symbol: Optional[str] = None, since: Optional[int] = None, limit: Optional[int] = None, params={}):
        """
        fetch all trades made by the user
        :param str|None symbol: unified market symbol
        :param int|None since: the earliest time in ms to fetch trades for
        :param int|None limit: the maximum number of trades structures to retrieve
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns [dict]: a list of `trade structures <https://docs.ccxt.com/#/?id=trade-structure>`
        """
        await self.load_markets()
        market = self.market(symbol)
        if params['account'] is None:
            raise ArgumentsRequired(self.id + ' fetchMyTrades() requires a account argument in params')
        request = {
            'account': params['account'],
            'symbol': market['symbol'],
        }
        request['limit'] = limit if (limit is not None) else 100
        request['offset'] = params['offset'] if (params['offset'] is not None) else 0
        if params['ordinal_order_ids'] is not None:
            request['ordinal_order_ids'] = params['ordinal_order_ids']
        response = await self.publicGetTradesHistory(self.extend(request, params))
        #
        #     [
        #         {
        #             "id": "32164924331503616",
        #             "symbol": "LINK_USDT",
        #             "accountType": "SPOT",
        #             "orderId": "32164923987566592",
        #             "side": "SELL",
        #             "type": "MARKET",
        #             "matchRole": "TAKER",
        #             "createTime": 1648635115525,
        #             "price": "11",
        #             "quantity": "0.5",
        #             "amount": "5.5",
        #             "feeCurrency": "USDT",
        #             "feeAmount": "0.007975",
        #             "pageId": "32164924331503616",
        #             "clientOrderId": "myOwnId-321"
        #         }
        #     ]
        #
        data = self.safe_value(response, 'data', [])
        return self.parse_trades(data, market, 1, 1, {'account': params['account']})

    async def fetch_orders(self, symbol: Optional[str] = None, since: Optional[int] = None, limit: Optional[int] = None, params={}):
        """
        get the list of most recent trades for a particular symbol
        :param str symbol: unified symbol of the market to fetch trades for
        :param int|None since: timestamp in ms of the earliest trade to fetch
        :param int|None limit: the maximum amount of trades to fetch
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns [dict]: a list of `trade structures <https://docs.ccxt.com/en/latest/manual.html?#public-trades>`
        """
        await self.load_markets()
        market = self.market(symbol)
        if params['account'] is None:
            raise ArgumentsRequired(self.id + ' fetchOrders() requires a account argument in params')
        request = {
            'account': params['account'],
            'symbol': market['symbol'],
        }
        request['offset'] = params['offset'] if (params['offset'] is not None) else 0
        request['limit'] = limit if (limit is not None) else 100
        if params['ordinal_order_ids'] is not None:
            request['ordinal_order_ids'] = params['ordinal_order_ids']
        if params['trx_id'] is not None:
            request['trx_id'] = params['trx_id']
        if params['status'] is not None:
            request['status'] = params['status']
        response = await self.publicGetOrdersHistory(self.extend(request, params))
        #
        #      {
        #          "data":[
        #              {
        #                  "id":"5ec36295-5c8d-4874-8d66-2609d4938557",
        #                  "price":"4050.06","size":"0.0044",
        #                  "market_name":"ETH-USDT",
        #                  "side":"sell",
        #                  "created_at":"2021-12-07T17:47:36.811000Z"
        #              },
        #          ]
        #      }
        #
        data = self.safe_value(response, 'data', [])
        return self.parse_orders(data, market)

    async def fetch_trades(self, symbol: str, since: Optional[int] = None, limit: Optional[int] = None, params={}):
        """
        get the list of most recent trades for a particular symbol
        :param str symbol: unified symbol of the market to fetch trades for
        :param int|None since: timestamp in ms of the earliest trade to fetch
        :param int|None limit: the maximum amount of trades to fetch
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns [dict]: a list of `trade structures <https://docs.ccxt.com/en/latest/manual.html?#public-trades>`
        """
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['symbol'],
        }
        request['limit'] = limit if (limit is not None) else 100
        request['offset'] = params['offset'] if (params['offset'] is not None) else 0
        response = await self.publicGetTradesRecent(self.extend(request, params))
        #
        #      {
        #          "data": [
        #              {
        #                  "id": "0718d520-c796-4061-a16b-915cd13f20c6",
        #                  "price": "0.00000358",
        #                  "size": "50.0",
        #                  "market_name": "DOGE-BTC",
        #                  "order_id": "ff2616d8-58d4-40fd-87ae-937c73eb6f1c",
        #                  "side": "buy",
        #                  "fee': "0.00000036",
        #                  "fee_currency_code": "btc",
        #                  "liquidity": "T",
        #                  "created_at": "2021-12-08T18:26:33.840000Z"
        #              },
        #          ]
        #      }
        #
        data = self.safe_value(response, 'data', [])
        return self.parse_trades(data, market, 1, 1)

    async def fetch_trading_fees(self, params={}):
        """
        fetch the trading fees for multiple markets
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns dict: a dictionary of `fee structures <https://docs.ccxt.com/en/latest/manual.html#fee-structure>` indexed by market symbols
        """
        await self.load_markets()
        response = await self.privateGetUserFees(params)
        #
        #    {
        #        data: {
        #            maker_fee: '0.0',
        #            taker_fee: '0.2',
        #            btc_volume_30d: '0.0'
        #        }
        #    }
        #
        data = self.safe_value(response, 'data', {})
        makerString = self.safe_string(data, 'maker_fee')
        takerString = self.safe_string(data, 'taker_fee')
        maker = self.parse_number(Precise.string_div(makerString, '100'))
        taker = self.parse_number(Precise.string_div(takerString, '100'))
        result = {}
        for i in range(0, len(self.symbols)):
            symbol = self.symbols[i]
            result[symbol] = {
                'info': response,
                'symbol': symbol,
                'maker': maker,
                'taker': taker,
                'percentage': True,
                'tierBased': True,
            }
        return result

    def parse_balance(self, response):
        result = {'info': response}
        balances = self.safe_value(response, 'data', [])
        for i in range(0, len(balances)):
            balance = balances[i]
            currencyId = self.safe_string(balance, 'currency')
            code = self.safe_currency_code(currencyId)
            account = self.account()
            account['token'] = self.safe_string(balance, 'contract')
            account['free'] = self.safe_string(balance, 'amount')
            account['total'] = self.safe_string(balance, 'amount')
            result[code] = account
        return self.safe_balance(result)

    async def fetch_balance(self, params={}):
        """
        query for balance and get the amount of funds available for trading or funds locked in orders
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns dict: a `balance structure <https://docs.ccxt.com/en/latest/manual.html?#balance-structure>`
        """
        await self.load_markets()
        if params['account'] is None:
            raise ArgumentsRequired(self.id + ' fetchOrders() requires a account argument in params')
        request = {
            'account': params['account'],
        }
        response = await self.publicGetAccountBalances(self.extend(request, params))
        return self.parse_balance(response)

    def parse_deposit_address(self, depositAddress, currency=None):
        #
        #     {
        #         "address":"0x77b5051f97efa9cc52c9ad5b023a53fc15c200d3",
        #         "tag":"0"
        #     }
        #
        address = self.safe_string(depositAddress, 'address')
        tag = self.safe_string(depositAddress, 'tag')
        self.check_address(address)
        return {
            'currency': self.safe_currency_code(None, currency),
            'address': address,
            'tag': tag,
            'network': None,
            'info': depositAddress,
        }

    def parse_order_status(self, status):
        statuses = {
            'fulfilled': 'closed',
            'canceled': 'canceled',
            'pending': 'open',
            'open': 'open',
            'partially_filled': 'open',
        }
        return self.safe_string(statuses, status, status)

    def parse_order(self, order, market=None):
        #
        #     {
        #         "id":"8bdd79f4-8414-40a2-90c3-e9f4d6d1eef4"
        #         "market":"IOT-BTC"
        #         "price":"0.0000003"
        #         "size":"4.0"
        #         "size_filled":"3.0"
        #         "fee":"0.0075"
        #         "fee_currency_code":"iot"
        #         "funds":"0.0"
        #         "status":"canceled"
        #         "order_type":"buy"
        #         "post_only":false
        #         "operation_type":"market_order"
        #         "created_at":"2018-01-12T21:14:06.747828Z"
        #     }
        #
        marketId = self.safe_string(order, 'market')
        symbol = self.safe_symbol(marketId, market, '-')
        timestamp = self.parse8601(self.safe_string(order, 'block_time'))
        priceString = self.safe_string(order, 'price')
        amountString = self.safe_string(order, 'quantity_init')
        remainingString = self.safe_string(order, 'quantity_curr')
        status = self.parse_order_status(self.safe_string(order, 'status'))
        type = self.safe_string(order, 'order_type')
        if type is not None:
            parts = type.split('_')
            type = parts[0]
        side = self.safe_string(order, 'order_side')
        return self.safe_order({
            'id': self.safe_string(order, 'order_id'),
            'clientOrderId': self.safe_string(order, 'ordinal_order_id'),
            'datetime': self.iso8601(timestamp),
            'timestamp': timestamp,
            'status': status,
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': priceString,
            'stopPrice': self.safe_string(order, 'trigger_price'),
            'cost': None,
            'amount': amountString,
            'remaining': remainingString,
            'fee': None,
        }, market)

    async def fetch_order(self, id, symbol=None, params={}):
        """
        fetches information on an order made by the user
        :param str|None symbol: unified symbol of the market the order was made in
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns dict: An `order structure <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        await self.load_markets()
        request = {
            'order_id': id,
        }
        if params['ordinal_order_id'] is not None:
            request['ordinal_order_id'] = params['ordinal_order_id']
        response = await self.publicGetOrdersLifecycle(self.extend(request, params))
        data = self.safe_value(response, 'data', {})
        return self.parse_order(data[0])

    async def fetch_open_orders(self, symbol: Optional[str] = None, since: Optional[int] = None, limit: Optional[int] = None, params={}):
        """
        fetch all unfilled currently open orders
        fetch all unfilled currently open orders
        :param str|None symbol: unified market symbol
        :param int|None since: the earliest time in ms to fetch open orders for
        :param int|None limit: the maximum number of  open orders structures to retrieve
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns [dict]: a list of `order structures <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        await self.load_markets()
        market = self.market(symbol)
        if params['account'] is None:
            raise ArgumentsRequired(self.id + ' fetchOrders() requires a account argument in params')
        request = {
            'account': params['account'],
            'symbol': market['symbol'],
        }
        request['offset'] = params['offset'] if (params['offset'] is not None) else 0
        request['limit'] = limit if (limit is not None) else 100
        if params['ordinal_order_ids'] is not None:
            request['ordinal_order_ids'] = params['ordinal_order_ids']
        response = await self.publicGetOrdersOpen(self.extend(request, params))
        data = self.safe_value(response, 'data', [])
        return self.parse_orders(data, market)

    async def fetch_deposits(self, code=None, since=None, limit=None, params={}):
        """
        fetch all deposits made to an account
        :param str|None code: unified currency code
        :param int|None since: the earliest time in ms to fetch deposits for
        :param int|None limit: the maximum number of deposits structures to retrieve
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns [dict]: a list of `transaction structures <https://docs.ccxt.com/en/latest/manual.html#transaction-structure>`
        """
        await self.load_markets()
        request = {
            # currency: 'xrp',  # optional: currency code in lowercase
            # status: 'completed',  # optional: withdrawal status
            # since_time  # datetime in ISO8601 format(2017-11-06T09:53:08.383210Z)
            # end_time  # datetime in ISO8601 format(2017-11-06T09:53:08.383210Z)
            # start_time  # datetime in ISO8601 format(2017-11-06T09:53:08.383210Z)
        }
        currency = None
        if code is not None:
            currency = self.currency(code)
            request['currency'] = self.safe_string_lower(currency, 'id')
        if since is not None:
            request['since_time'] = self.iso8601(since)
        response = await self.privateGetAccountDeposits(self.extend(request, params))
        #
        #     data: [
        #         {
        #             id: '6e2f18b5-f80e-xxx-xxx-xxx',
        #             amount: '0.1',
        #             status: 'completed',
        #             currency_code: 'eth',
        #             txid: '0xxxx',
        #             address: '0xxxx',
        #             tag: null,
        #             type: 'deposit'
        #         },
        #     ]
        #
        transactions = self.safe_value(response, 'data', [])
        transactions.reverse()  # no timestamp but in reversed order
        return self.parse_transactions(transactions, currency, None, limit)

    async def fetch_withdrawals(self, code=None, since=None, limit=None, params={}):
        """
        fetch all withdrawals made from an account
        :param str|None code: unified currency code
        :param int|None since: the earliest time in ms to fetch withdrawals for
        :param int|None limit: the maximum number of withdrawals structures to retrieve
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns [dict]: a list of `transaction structures <https://docs.ccxt.com/en/latest/manual.html#transaction-structure>`
        """
        await self.load_markets()
        request = {
            # currency: 'xrp',  # optional: currency code in lowercase
            # status: 'completed',  # optional: withdrawal status
            # since_time  # datetime in ISO8601 format(2017-11-06T09:53:08.383210Z)
            # end_time  # datetime in ISO8601 format(2017-11-06T09:53:08.383210Z)
            # start_time  # datetime in ISO8601 format(2017-11-06T09:53:08.383210Z)
        }
        currency = None
        if code is not None:
            currency = self.currency(code)
            request['currency'] = self.safe_string_lower(currency, 'id')
        if since is not None:
            request['since_time'] = self.iso8601(since)
        response = await self.privateGetAccountWithdrawals(self.extend(request, params))
        #
        #     data: [
        #         {
        #             id: '25f6f144-3666-xxx-xxx-xxx',
        #             amount: '0.01',
        #             status: 'completed',
        #             fee: '0.0005',
        #             currency_code: 'btc',
        #             txid: '4xxx',
        #             address: 'bc1xxx',
        #             tag: null,
        #             type: 'withdraw'
        #         },
        #     ]
        #
        transactions = self.safe_value(response, 'data', [])
        transactions.reverse()  # no timestamp but in reversed order
        return self.parse_transactions(transactions, currency, None, limit)

    def parse_transaction_status(self, status):
        statuses = {
            'completed': 'ok',
            'denied': 'failed',
            'approval_pending': 'pending',
        }
        return self.safe_string(statuses, status, status)

    def parse_transaction(self, transaction, currency=None):
        #
        # fetchWithdrawals, withdraw
        #
        #     {
        #         id: '25f6f144-3666-xxx-xxx-xxx',
        #         amount: '0.01',
        #         status: 'completed',
        #         fee: '0.0005',
        #         currency_code: 'btc',
        #         txid: '4xxx',
        #         address: 'bc1xxx',
        #         tag: null,
        #         type: 'withdraw'
        #     },
        #
        # fetchDeposits
        #
        #     {
        #         id: '6e2f18b5-f80e-xxx-xxx-xxx',
        #         amount: '0.1',
        #         status: 'completed',
        #         currency_code: 'eth',
        #         txid: '0xxxx',
        #         address: '0xxxx',
        #         tag: null,
        #         type: 'deposit'
        #     },
        #
        id = self.safe_string(transaction, 'id')
        address = self.safe_string(transaction, 'address')
        tag = self.safe_string(transaction, 'tag')
        txid = self.safe_string(transaction, 'txid')
        currencyId = self.safe_string(transaction, 'currency_code')
        code = self.safe_currency_code(currencyId, currency)
        type = self.safe_string(transaction, 'type')
        if type == 'withdraw':
            type = 'withdrawal'
        status = self.parse_transaction_status(self.safe_string(transaction, 'status'))
        amountString = self.safe_string(transaction, 'amount')
        amount = self.parse_number(amountString)
        feeCostString = self.safe_string(transaction, 'fee')
        feeCost = 0
        if feeCostString is not None:
            feeCost = self.parse_number(feeCostString)
        return {
            'info': transaction,
            'id': id,
            'txid': txid,
            'timestamp': None,
            'datetime': None,
            'network': None,
            'address': address,
            'addressTo': None,
            'addressFrom': None,
            'tag': tag,
            'tagTo': None,
            'tagFrom': None,
            'type': type,
            'amount': amount,
            'currency': code,
            'status': status,
            'updated': None,
            'fee': {
                'currency': code,
                'cost': feeCost,
            },
        }

    def nonce(self):
        return self.milliseconds()

    async def fetch_status_sync(self, params={}):
        """
        fetch synchronization time
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns dict: a `balance structure <https://docs.ccxt.com/en/latest/manual.html?#balance-structure>`
        """
        response = await self.publicGetStatusSync()
        #
        #     [
        #         {
        #           "dbSecondsBehind": 0,
        #           "chronicleSecondsBehind": 0,
        #           "maxSecondsBehind": 0
        #         }
        #     ]
        return response

    async def fetch_ohlcv(self, symbol: str, timeframe='1W', since: Optional[int] = None, limit: Optional[int] = None, params={}):
        """
        retrive ohlcv charts
        :param int timeframe: duration of the input
        :param str symbol: unified market symbol
        :param timestamp from_time: start date and time
        :param timestamp to_time: end date and time
        :param integer|None limit: count to fetch
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns [[int]]: A list of candles ordered, open, high, low, close, volume
        """
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'interval': timeframe,
            'symbol': market['symbol'],
        }
        currentTimestamp = self.milliseconds()
        oneMonth = 30 * 24 * 60 * 60 * 1000
        if params['from_time'] is not None:
            request['from'] = self.ymdhms(self.parse_date(params['from_time']))
        else:
            startTime = currentTimestamp - oneMonth
            request['from'] = self.ymdhms(startTime)
        if params['to_time'] is not None:
            request['to'] = self.ymdhms(self.parse_date(params['to_time']))
        else:
            request['to'] = self.ymdhms(currentTimestamp)
        request['limit'] = limit if (limit is not None) else 100
        response = await self.publicGetChartOhlcv(self.extend(request, params))
        #
        #   [
        #      {
        #           'close': '0.76',
        #           'count': '0',
        #           'high': '0.76',
        #           'low': '0.76',
        #           'open': '0.76',
        #           'time': '1665950400000',
        #           'volume': '0',
        #           'volume_bid': '0'
        #       }
        #   ]
        transResults = self.safe_value(response, 'data', [])
        results = []
        for i in range(0, len(transResults)):
            results.append(self.parse_ohlcv(transResults[i], market))
        return transResults

    def digest_suffix_ripemd160(self, data, suffix: str):
        d = Uint8Array(len(data) + len(suffix))
        for i in range(0, len(data)):
            d[i] = data[i]
        for i in range(0, len(suffix)):
            len = len(data) + i
            d[len] = suffix.charCodeAt(i)
        return ripemd160(d)

    def key_to_string(self, keyData, suffix: str, prefix: str):
        digest = Uint8Array(self.digest_suffix_ripemd160(keyData, suffix))
        whole = Uint8Array(len(keyData) + 4)
        for i in range(0, len(keyData)):
            whole[i] = keyData[i]
        for i in range(0, 4):
            whole[i + len(keyData)] = digest[i]
        return prefix + self.binary_to_base58(whole)

    def string_to_key(self, s: str, size: float, suffix: str):
        whole = self.base58_to_binary(s)
        data = Uint8Array(whole.buffer, 0, len(whole) - 4)
        digest = Uint8Array(self.digest_suffix_ripemd160(data, suffix))
        digestStatus = (digest[0] != whole[(len(whole)) - 4] or digest[1] != whole[(len(whole)) - 3]
                             or digest[2] != whole[(len(whole)) - 2] or digest[3] != whole[(len(whole)) - 1])
        if digestStatus:
            raise Error("checksum doesn't match")
        return data

    def from_elliptic(self, ellipticSig):
        ellipticSig.recovery = ellipticSig.recovery or 0
        r = numberToBytesBE(ellipticSig.r, 32)
        s = numberToBytesBE(ellipticSig.s, 32)
        eosioRecoveryParam = 0
        eosioRecoveryParam = ellipticSig.recovery + 27
        if ellipticSig.recovery <= 3:
            eosioRecoveryParam += 4
        initParams = Uint8Array([eosioRecoveryParam])
        sigData = concatBytes(initParams, r, s)
        return self.key_to_string(sigData, 'K1', 'SIG_K1_')

    def get_signatures(self, transHex):
        chainID = '384da888112027f0321850a169f737c33e53b388aad48b5adace4bab97f437e0'
        sandboxMode = self.safe_value(self.options, 'sandboxMode', False)
        if sandboxMode:
            chainID = '71ee83bcf52142d61019d95f9cc5427ba6a0d7ff8accd9e2088ae2abeaf3d3dd'
        e = secp256k1
        signatures = []
        initData = Uint8Array(32)
        signBuf = concatBytes(hexToBytes(chainID), transHex, initData)
        digest = e.CURVE.hash(signBuf)
        arrayData = None
        if self.secret.substr(0, 7) == 'PVT_K1_':
            arrayData = self.string_to_key(self.secret.substr(7), 32, 'K1')
        else:
            whole = self.base58_to_binary(self.secret)
            keyData = Uint8Array(32)
            for i in range(0, 32):
                keyData[i] = whole[i + 1]
            arrayData = keyData
        rawSignature = e.sign(digest, arrayData)
        signature = self.from_elliptic(rawSignature)
        signatures.append(signature)
        return signatures

    def set_sandbox_mode(self, enable):
        super(protondex, self).set_sandbox_mode(enable)
        self.options['sandboxMode'] = enable

    async def create_order(self, symbol: str, type, side: OrderSide, amount, price=None, params={}):
        """
        create a trade order
        see https://api-docs.protondex.com/reference/orderscontroller_submitorder
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much of currency you want to trade in units of base currency
        :param float|None price: the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        await self.load_markets()
        if self.secret is None:
            raise ArgumentsRequired('createOrder call requires a secret to be set')
        market = self.market(symbol)
        marketid = int(market.info.market_id)
        accountName = self.safe_string(params, 'account')
        orderType = int(type)
        orderSide = int(side)
        orderFillType = self.safe_value(params, 'filltype')
        orderAmount = amount
        triggerPrice = self.safe_value(params, 'triggerprice')
        referrerName = params['referrer'] if (params['referrer'] is not None) else ''
        bidTokenPrecision = self.parse_to_int(market.info.bid_token.precision)
        askTokenPrecision = self.parse_to_int(market.info.ask_token.precision)
        bidTokenCode = str(market.info.bid_token.code)
        askTokenCode = str(market.info.ask_token.code)
        bidTokenContract = str(market.info.bid_token.contract)
        askTokenContract = str(market.info.ask_token.contract)
        quantityText = format((orderAmount, '.' + str(bidTokenPrecision) + 'f') + ' ' + bidTokenCode) if (orderSide == 2) else format((orderAmount, '.' + str(askTokenPrecision) + 'f') + ' ' + askTokenCode)
        tokenContract = orderSide == bidTokenContract if 2 else askTokenContract
        bidMultiplier = (orderAmount * self.parse_to_int(market.info.bid_token.multiplier))
        askMultiplier = (orderAmount * self.parse_to_int(market.info.ask_token.multiplier))
        quantity = str(bidMultiplier) if (orderSide == 2) else str(askMultiplier)
        orderPrice = Number(price) * Number(math.pow(10, format(askTokenPrecision), '.0f'))
        auth = {'actor': accountName, 'permission': 'active'}
        action1 = {
            'account': tokenContract,
            'name': 'transfer',
            'data': {
                'from': accountName,
                'to': 'dex',
                'quantity': quantityText,
                'memo': '',
            },
            'authorization': [auth],
        }
        action2 = {
            'account': 'dex',
            'name': 'placeorder',
            'data': {
                'market_id': marketid,
                'account': accountName,
                'order_type': orderType,
                'order_side': orderSide,
                'fill_type': orderFillType,
                'bid_symbol': {
                    'sym': bidTokenPrecision + ',' + bidTokenCode,
                    'contract': bidTokenContract,
                },
                'ask_symbol': {
                    'sym': askTokenPrecision + ',' + askTokenCode,
                    'contract': askTokenContract,
                },
                'referrer': referrerName,
                'quantity': quantity,
                'price': orderPrice,
                'trigger_price': triggerPrice,
            },
            'authorization': [auth],
        }
        action3 = {
            'account': 'dex',
            'name': 'process',
            'data': {
                'q_size': 20,
                'show_error_msg': 0,
            },
            'authorization': [auth],
        }
        actions = [action1, action2, action3]
        request = {
            'transaction': {actions},
        }
        orderDetails = []
        retries = 5
        while(retries > 0):
            try:
                serResponse = await self.publicPostOrdersSerialize(self.extend(request))
                result = self.safe_value(serResponse, 'data', [])
                tx = hexToBytes(result['serialized_tx_hex'])
                signatures = self.get_signatures(tx)
                orderRequest = {
                    'serialized_tx_hex': str(result['serialized_tx_hex']),
                    'signatures': signatures,
                }
                response = await self.publicPostOrdersSubmit(self.extend(orderRequest))
                data = self.safe_value(response, 'data', [])
                # Response format
                # {
                #     trx_id: 'd6124ed37ba30f499ec3043c185d6e458c7f4a581e09a4f3cefe64c723426af0',
                #     block_time: '2023-06-16T19:10:30.000Z',
                #     orders: [
                #         {
                #             ordinal_order_id: '378b28d5164be48adc7c0c7c02a9803abc4109185f11cc6116864e94878ff5cc',
                #             order_id: '3990837',
                #             status: 'create'
                #         }
                #     ]
                # }
                orderDetails['ordinal_order_id'] = data.orders[0].ordinal_order_id
                orderDetails['order_id'] = data.orders[0].order_id
                orderDetails['status'] = data.orders[0].status
                orderDetails['block_time'] = data['block_time']
                orderDetails['symbol'] = symbol
                orderDetails['order_type'] = orderType
                orderDetails['order_side'] = orderSide
                orderDetails['price'] = orderPrice
                orderDetails['trigger_price'] = triggerPrice
                retries = 0
            except Exception as e:
                if self.last_json_response:
                    message = self.safe_string(self.last_json_response.error.details[0], 'message')
                    if message == 'is_canonical( c ): signature is not canonical':
                        --retries
                    else:
                        retries = 0
                if not retries:
                    raise e
        return self.parse_order(orderDetails, market)

    async def cancel_order(self, id: str, symbol: Optional[str] = None, params={}):
        """
        cancels an open order
        :param str id: order id
        :param str|None symbol: unified symbol of the market the order was made in
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns dict: An `order structure <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        await self.load_markets()
        if self.secret is None:
            raise ArgumentsRequired('cancelOrder call requires a secret to be set')
        orderId = int(id)
        accountName = self.safe_string(params, 'account')
        auth = {'actor': accountName, 'permission': 'active'}
        action1 = {
            'account': 'dex',
            'name': 'cancelorder',
            'data': {
                'account': accountName,
                'order_id': orderId,
            },
            'authorization': [auth],
        }
        action2 = {
            'account': 'dex',
            'name': 'withdrawall',
            'data': {
                'account': accountName,
            },
            'authorization': [auth],
        }
        actions = [action1, action2]
        request = {
            'transaction': {actions},
        }
        data = None
        retries = 5
        while(retries > 0):
            try:
                serResponse = await self.publicPostOrdersSerialize(self.extend(request))
                result = self.safe_value(serResponse, 'data', [])
                tx = hexToBytes(result['serialized_tx_hex'])
                signatures = self.get_signatures(tx)
                orderRequest = {
                    'serialized_tx_hex': str(result['serialized_tx_hex']),
                    'signatures': signatures,
                }
                response = await self.publicPostOrdersSubmit(self.extend(orderRequest))
                data = self.safe_value(response, 'data', [])
                retries = 0
            except Exception as e:
                if self.last_json_response:
                    message = self.safe_string(self.last_json_response.error.details[0], 'message')
                    if message == 'is_canonical( c ): signature is not canonical':
                        --retries
                    else:
                        retries = 0
                if not retries:
                    raise e
        return data

    async def getorder_ids(self, name: str, symbol: str):
        try:
            cancelList = []
            i = 0
            while(i > 5):
                ordersList = await self.fetch_open_orders(symbol, 1, 100, {'account': name, 'offset': 100 * i, 'ordinal_order_ids': ''})
                if not len(ordersList):
                    break
                for j in range(0, len(ordersList)):
                    cancelList.append(ordersList[j]['id'])
                ++i
            return cancelList
        except Exception as e:
            raise OrderNotFound(' calcelAllOrders() error: order not found')

    async def cancel_all_orders(self, symbol=None, params={}):
        """
        cancel all open orders
        :param str|None symbol: unified market symbol, only orders in the market of self symbol are cancelled when symbol is not None
        :param dict params: extra parameters specific to the bittrex api endpoint
        :returns [dict]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        await self.load_markets()
        market = self.market(symbol)
        if self.secret is None:
            raise ArgumentsRequired('cancelOrder call requires a secret to be set')
        accountName = self.safe_string(params, 'account')
        orderList = await self.getorder_ids(accountName, market['symbol'])
        if not len(orderList):
            raise OrderNotFound(' calcelAllOrders() error: no orders found')
        actions = []
        auth = {'actor': accountName, 'permission': 'active'}
        for i in range(0, len(orderList)):
            action = {
                'account': 'dex',
                'name': 'cancelorder',
                'data': {
                    'account': accountName,
                    'order_id': orderList[i],
                },
                'authorization': [auth],
            }
            actions.append(action)
        withdrawAction = {
            'account': 'dex',
            'name': 'withdrawall',
            'data': {
                'account': accountName,
            },
            'authorization': [auth],
        }
        actions.append(withdrawAction)
        request = {
            'transaction': {actions},
        }
        data = None
        retries = 5
        while(retries > 0):
            try:
                serResponse = await self.publicPostOrdersSerialize(self.extend(request))
                result = self.safe_value(serResponse, 'data', [])
                tx = hexToBytes(result['serialized_tx_hex'])
                signatures = self.get_signatures(tx)
                orderRequest = {
                    'serialized_tx_hex': str(result['serialized_tx_hex']),
                    'signatures': signatures,
                }
                response = await self.publicPostOrdersSubmit(self.extend(orderRequest))
                data = self.safe_value(response, 'data', [])
                retries = 0
            except Exception as e:
                if self.last_json_response:
                    message = self.safe_string(self.last_json_response.error.details[0], 'message')
                    if message == 'is_canonical( c ): signature is not canonical':
                        --retries
                    else:
                        retries = 0
                if not retries:
                    raise e
        return data

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        url = self.urls['api']['rest']
        request = '/' + self.version + '/' + self.implode_params(path, params)
        query = self.omit(params, self.extract_params(path))
        implodedPath = self.implode_params(path, params)
        if api == 'public':
            if (method == 'POST') or (method == 'PUT') or (method == 'DELETE'):
                if query:
                    body = self.json(query)
                headers = {
                    'Content-Type': 'application/json',
                }
            elif query:
                request += '?' + self.urlencode(query)
        else:
            self.check_required_credentials()
            timestamp = str(self.nonce())
            auth = method + "\n"  # eslint-disable-line quotes
            url += '/' + implodedPath
            auth += '/' + implodedPath
            if (method == 'POST') or (method == 'PUT') or (method == 'DELETE'):
                auth += "\n"  # eslint-disable-line quotes
                if query:
                    body = self.json(query)
                    auth += 'requestBody=' + body + '&'
                auth += 'signTimestamp=' + timestamp
            else:
                sortedQuery = self.extend({'signTimestamp': timestamp}, query)
                sortedQuery = self.keysort(sortedQuery)
                auth += "\n" + self.urlencode(sortedQuery)  # eslint-disable-line quotes
                if query:
                    url += '?' + self.urlencode(query)
            signature = self.hmac(self.encode(auth), self.encode(self.secret), hashlib.sha256, 'base64')
            headers = {
                'Content-Type': 'application/json',
                'key': self.apiKey,
                'signTimestamp': timestamp,
                'signature': signature,
            }
        url = url + request
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, code, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if not response:
            return  # fallback to default error handler
        error = self.safe_value(response, 'error')
        if error is not None:
            errorCode = self.safe_string(error, 'code')
            feedback = self.id + ' ' + body
            self.throw_exactly_matched_exception(self.exceptions, errorCode, feedback)
            raise ExchangeError(feedback)  # unknown message
