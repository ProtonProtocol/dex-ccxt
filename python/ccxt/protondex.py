# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
from ccxt.abstract.protondex import ImplicitAPI
import hashlib
import math
from ccxt.base.types import OrderSide
from typing import Optional
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import OrderNotFound
from ccxt.base.decimal_to_precision import TICK_SIZE
from ccxt.base.precise import Precise


class protondex(Exchange, ImplicitAPI):

    def describe(self):
        return self.deep_extend(super(protondex, self).describe(), {
            'id': 'protondex',
            'name': 'protondex',
            'countries': ['US'],
            'rateLimit': 600,
            'version': 'v1',
            'has': {
                'CORS': None,
                'spot': True,
                'margin': False,
                'swap': False,
                'future': False,
                'option': False,
                'addMargin': False,
                'cancelOrder': True,
                'createOrder': True,
                'createReduceOnlyOrder': False,
                'createStopLimitOrder': False,
                'createStopMarketOrder': False,
                'createStopOrder': False,
                'fetchBalance': True,
                'fetchBorrowRate': False,
                'fetchBorrowRateHistories': False,
                'fetchBorrowRateHistory': False,
                'fetchBorrowRates': False,
                'fetchBorrowRatesPerSymbol': False,
                'fetchCurrencies': False,
                'fetchDepositAddress': False,
                'fetchDepositAddresses': False,
                'fetchDeposits': True,
                'fetchFundingHistory': False,
                'fetchFundingRate': False,
                'fetchFundingRateHistory': False,
                'fetchFundingRates': False,
                'fetchIndexOHLCV': False,
                'fetchL2OrderBook': False,
                'fetchLeverage': False,
                'fetchLeverageTiers': False,
                'fetchMarginMode': False,
                'fetchMarkets': True,
                'fetchMarkOHLCV': False,
                'fetchMyTrades': True,
                'fetchOHLCV': True,
                'fetchOpenInterestHistory': False,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchOrders': True,
                'fetchOrderTrades': True,
                'fetchPosition': False,
                'fetchPositionMode': False,
                'fetchPositions': False,
                'fetchPositionsRisk': False,
                'fetchPremiumIndexOHLCV': False,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTrades': True,
                'fetchTradinFee': False,
                'fetchTradingFees': True,
                'fetchTransfer': False,
                'fetchTransfers': False,
                'fetchWithdrawals': False,
                'reduceMargin': False,
                'setLeverage': False,
                'setMarginMode': False,
                'setPositionMode': False,
                'transfer': False,
                'withdraw': False,
            },
            'hostname': 'https://dex.api.mainnet.metalx.com',
            'urls': {
                'logo': 'https://protonswap.com/img/logo.svg',
                'api': {
                    'rest': 'https://dex.api.mainnet.metalx.com/dex',
                    'public': 'https://dex.api.mainnet.metalx.com/dex',
                    'private': 'https://dex.api.mainnet.metalx.com/dex',
                },
                'test': {
                    'rest': 'https://dex.api.testnet.metalx.com/dex',
                    'public': 'https://dex.api.testnet.metalx.com/dex',
                    'private': 'https://dex.api.testnet.metalx.com/dex',
                },
                'www': 'https://app.metalx.com/dex/',
                'doc': [
                    'https://docs.metalx.com/dex/what-is-metal-x',
                ],
                'fees': [
                    'https://docs.metalx.com/dex/what-is-metal-x/dex-fees-and-discounts',
                ],
                'referral': 'https://app.metalx.com/dex/',
            },
            'api': {
                'public': {
                    'get': [
                        'markets/all',
                        'orders/open',  # ?{account}/{marketid}/{offset}/{limit}'
                        'orders/history',  # ?{account}/{marketid}/{offset}/{limit}'
                        'orders/lifecycle',  # ?{orderid}'
                        'orders/depth',  # ?{marketid}/{step}/{limit}'
                        'trades/daily',
                        'trades/history',  # ?{account}/{symbol}/{offset}/{ordinal_order_ids}/{limit}'
                        'trades/recent',  # ?{marketid}/{offset}/{limit}'
                        'chart/ohlcv',  # ?{interval}/{dateFrom}/{dateTo}/{marketid}/{limit}'
                        'status/sync',
                        'account/balances',  # ?{account}'
                    ],
                    'post': [
                        'orders/serialize',  # application/json - transaction
                        'orders/submit',  # application/json - serilized_tx_hex, signatures
                    ],
                },
                'private': {
                    'post': [
                    ],
                    'get': [
                        'user/fees',
                        'account/deposits',
                        'account/withdrawals',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'tierBased': True,
                    'maker': 0.001,  # tiered fee discounts
                    'taker': 0.001,  # tiered fee discounts
                },
            },
            'precision': {
                'amount': self.parse_number('0.00000001'),
                'price': self.parse_number('0.00000001'),
            },
            'precisionMode': TICK_SIZE,
        })

    def fetch_markets(self, params={}):
        """
        retrieves data on all markets for protondex
        :param dict params: extra parameters specific to the exchange api endpoint
        :returns [dict]: an array of objects representing market data
        """
        response = self.publicGetMarketsAll(params)
        #
        #    {
        #        "data": [
        #            {
        #                "name": "ETH-BTC",
        #                "precision": 6,
        #                "min_volume": "0.00000001",
        #                "min_price": "0.000001",
        #                "volume": "0.015713",
        #                "last_price": "0.069322",
        #                "highest_bid": "0.063892",
        #                "lowest_ask": "0.071437",
        #                "change_in_24h": "2.85",
        #                "size_precision": 8,
        #                "price_precision": 6
        #            },
        #            ...
        #        ]
        #    }
        #
        markets = self.safe_value(response, 'data', [])
        result = []
        for i in range(0, len(markets)):
            market = markets[i]
            baseId, quoteId = market['symbol'].split('_')
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            result.append({
                'id': market['symbol'],
                'symbol': market['symbol'],
                'base': base,
                'quote': quote,
                'settle': None,
                'baseId': baseId,
                'quoteId': quoteId,
                'settleId': None,
                'type': 'spot',
                'spot': True,
                'margin': False,
                'swap': False,
                'future': False,
                'option': False,
                'active': True,
                'contract': False,
                'linear': None,
                'inverse': None,
                'taker': self.safe_value(market, 'taker_fee'),
                'maker': self.safe_value(market, 'maker_fee'),
                'contractSize': None,
                'expiry': None,
                'expiryDatetime': None,
                'strike': None,
                'optionType': None,
                'precision': {
                    'amount': self.parse_number(self.parse_precision(market['bid_token']['precision'])),
                    'price': self.parse_number(self.parse_precision(market['ask_token']['precision'])),
                },
                'limits': {
                    'leverage': {
                        'min': None,
                        'max': None,
                    },
                    'amount': {
                        'min': self.safe_number(market, 'minPrice'),
                        'max': None,
                    },
                    'price': {
                        'min': self.safe_number(market, 'minVolume'),
                        'max': None,
                    },
                    'cost': {
                        'min': None,
                        'max': None,
                    },
                },
                'info': market,
            })
        return result

    def parse_ticker(self, ticker, market=None):
        #
        #     {
        #         "name":"ETH-BTC",
        #         "precision":6,
        #         "min_volume":"0.00000001",
        #         "min_price":"0.000001",
        #         "volume":"0.000452",
        #         "last_price":"0.079059",
        #         "highest_bid":"0.073472",
        #         "lowest_ask":"0.079059",
        #         "change_in_24h":"8.9",
        #         "size_precision":8,
        #         "price_precision":6
        #     }
        #
        marketId = self.safe_string(ticker, 'name')
        market = self.safe_market(marketId, market, '-')
        timestamp = self.milliseconds()
        last = self.safe_string(ticker, 'last_price')
        return self.safe_ticker({
            'symbol': ticker['symbol'],
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_string(ticker, 'high'),
            'low': self.safe_string(ticker, 'low'),
            'bid': self.safe_string(ticker, 'highest_bid'),
            'bidVolume': self.safe_string(ticker, 'volume_bid'),
            'ask': self.safe_string(ticker, 'lowest_ask'),
            'askVolume': self.safe_string(ticker, 'volume_ask'),
            'vwap': None,
            'open': self.safe_string(ticker, 'open'),
            'close': self.safe_string(ticker, 'close'),
            'last': last,
            'previousClose': None,
            'change': None,
            'percentage': self.safe_string(ticker, 'change_percentage'),
            'average': None,
            'baseVolume': None,
            'quoteVolume': self.safe_string(ticker, 'volume'),
            'info': ticker,
        }, market)

    def fetch_ticker(self, symbol, params={}):
        """
        fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        :param str symbol: unified symbol of the market to fetch the ticker for
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns dict: a `ticker structure <https://docs.ccxt.com/en/latest/manual.html#ticker-structure>`
        """
        self.load_markets()
        tickers = self.fetch_tickers()
        return tickers[symbol]

    def fetch_tickers(self, symbols=None, params={}):
        """
        fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
        :param [str]|None symbols: unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns dict: an array of `ticker structures <https://docs.ccxt.com/en/latest/manual.html#ticker-structure>`
        """
        self.load_markets()
        symbols = self.market_symbols(symbols)
        response = self.publicGetTradesDaily(params)
        #
        #     {
        #         "data":[
        #             {
        #                 "name":"ETH-BTC",
        #                 "precision":6,
        #                 "min_volume":"0.00000001",
        #                 "min_price":"0.000001",
        #                 "volume":"0.000452",
        #                 "last_price":"0.079059",
        #                 "highest_bid":"0.073472",
        #                 "lowest_ask":"0.079059",
        #                 "change_in_24h":"8.9",
        #                 "size_precision":8,
        #                 "price_precision":6
        #             }
        #         ]
        #     }
        #
        tickers = self.safe_value(response, 'data', [])
        result = {}
        for i in range(0, len(tickers)):
            ticker = self.parse_ticker(tickers[i])
            symbol = ticker['symbol']
            result[symbol] = ticker
        return self.filter_by_array(result, 'symbol', symbols)

    def fetch_order_book(self, symbol, limit=None, params={}):
        """
        fetches information on open orders with bid(buy) and ask(sell) prices, volumes and other data
        :param str symbol: unified symbol of the market to fetch the order book for
        :param int|None limit: the maximum amount of order book entries to return
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns dict: A dictionary of `order book structures <https://docs.ccxt.com/en/latest/manual.html#order-book-structure>` indexed by market symbols
        """
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['symbol'],
        }
        request['limit'] = limit if (limit is not None) else 100
        request['step'] = params['step'] if (params['step'] is not None) else 100
        response = self.publicGetOrdersDepth(self.extend(request, params))
        data = self.safe_value(response, 'data', {})
        return self.parse_order_book(data, market['symbol'], None, 'bids', 'asks', 'level', 'bid')

    def parse_trade(self, trade, market=None):
        #
        # fetchTrades(public)
        #
        #      {
        #          "id":"5ec36295-5c8d-4874-8d66-2609d4938557",
        #          "price":"4050.06","size":"0.0044",
        #          "market_name":"ETH-USDT",
        #          "side":"sell",
        #          "created_at":"2021-12-07T17:47:36.811000Z"
        #      }
        #
        # fetchMyTrades(private)
        #
        #      {
        #              "id": "0718d520-c796-4061-a16b-915cd13f20c6",
        #              "price": "0.00000358",
        #              "size": "50.0",
        #              "market_name": "DOGE-BTC",
        #              "order_id": "ff2616d8-58d4-40fd-87ae-937c73eb6f1c",
        #              "side": "buy",
        #              "fee': "0.00000036",
        #              "fee_currency_code": "btc",
        #              "liquidity": "T",
        #              "created_at": "2021-12-08T18:26:33.840000Z"
        #      }
        #
        timestamp = self.parse8601(self.safe_string(trade, 'block_time'))
        tradeId = self.safe_string(trade, 'trade_id')
        priceString = self.safe_string(trade, 'price')
        orderSide = self.safe_string(trade, 'order_side')
        account = self.safe_string(trade, 'account')
        amountString = account == self.safe_string(trade, 'bid_amount') if self.safe_string(trade, 'bid_user') else self.safe_string(trade, 'ask_amount')
        orderId = account == self.safe_string(trade, 'bid_user_ordinal_order_id') if self.safe_string(trade, 'bid_user') else self.safe_string(trade, 'ask_user_ordinal_order_id')
        feeString = account == self.safe_string(trade, 'bid_fee') if self.safe_string(trade, 'bid_user') else self.safe_string(trade, 'ask_fee')
        feeCurrencyId = account == self.safe_string(market, 'baseId') if self.safe_string(trade, 'bid_user') else self.safe_string(market, 'quoteId')
        fee = None
        if feeString is not None:
            feeCurrencyCode = self.safe_currency_code(feeCurrencyId)
            fee = {
                'cost': feeString,
                'currency': feeCurrencyCode,
            }
        orderCost = account == self.safe_string(trade, 'ask_amount') if self.safe_string(trade, 'bid_user') else self.safe_string(trade, 'bid_amount')
        return self.safe_trade({
            'info': trade,
            'id': tradeId,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': market['symbol'],
            'order': orderId,
            'type': None,
            'side': orderSide,
            'takerOrMaker': None,
            'price': priceString,
            'amount': amountString,
            'cost': orderCost,
            'fee': fee,
        }, market)

    def parse_trades(self, trades, market: Optional[object] = None, since: Optional[int] = None, limit: Optional[int] = None, params={}):
        trades = self.to_array(trades)
        result = []
        for i in range(0, len(trades)):
            trades[i]['account'] = params['account']
            trade = self.extend(self.parse_trade(trades[i], market))
            result.append(trade)
        return result

    def fetch_my_trades(self, symbol: Optional[str] = None, since: Optional[int] = None, limit: Optional[int] = None, params={}):
        """
        fetch all trades made by the user
        :param str|None symbol: unified market symbol
        :param int|None since: the earliest time in ms to fetch trades for
        :param int|None limit: the maximum number of trades structures to retrieve
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns [dict]: a list of `trade structures <https://docs.ccxt.com/#/?id=trade-structure>`
        """
        self.load_markets()
        market = self.market(symbol)
        if params['account'] is None:
            raise ArgumentsRequired(self.id + ' fetchMyTrades() requires a account argument in params')
        request = {
            'account': params['account'],
            'symbol': market['symbol'],
        }
        request['limit'] = limit if (limit is not None) else 100
        request['offset'] = params['offset'] if (params['offset'] is not None) else 0
        if params['ordinal_order_ids'] is not None:
            request['ordinal_order_ids'] = params['ordinal_order_ids']
        response = self.publicGetTradesHistory(self.extend(request, params))
        #
        #     [
        #         {
        #             "id": "32164924331503616",
        #             "symbol": "LINK_USDT",
        #             "accountType": "SPOT",
        #             "orderId": "32164923987566592",
        #             "side": "SELL",
        #             "type": "MARKET",
        #             "matchRole": "TAKER",
        #             "createTime": 1648635115525,
        #             "price": "11",
        #             "quantity": "0.5",
        #             "amount": "5.5",
        #             "feeCurrency": "USDT",
        #             "feeAmount": "0.007975",
        #             "pageId": "32164924331503616",
        #             "clientOrderId": "myOwnId-321"
        #         }
        #     ]
        #
        data = self.safe_value(response, 'data', [])
        return self.parse_trades(data, market, 1, 1, {'account': params['account']})

    def fetch_orders(self, symbol: Optional[str] = None, since: Optional[int] = None, limit: Optional[int] = None, params={}):
        """
        get the list of most recent trades for a particular symbol
        :param str symbol: unified symbol of the market to fetch trades for
        :param int|None since: timestamp in ms of the earliest trade to fetch
        :param int|None limit: the maximum amount of trades to fetch
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns [dict]: a list of `trade structures <https://docs.ccxt.com/en/latest/manual.html?#public-trades>`
        """
        self.load_markets()
        market = self.market(symbol)
        if params['account'] is None:
            raise ArgumentsRequired(self.id + ' fetchOrders() requires a account argument in params')
        request = {
            'account': params['account'],
            'symbol': market['symbol'],
        }
        request['offset'] = params['offset'] if (params['offset'] is not None) else 0
        request['limit'] = limit if (limit is not None) else 100
        if params['ordinal_order_ids'] is not None:
            request['ordinal_order_ids'] = params['ordinal_order_ids']
        if params['trx_id'] is not None:
            request['trx_id'] = params['trx_id']
        if params['status'] is not None:
            request['status'] = params['status']
        response = self.publicGetOrdersHistory(self.extend(request, params))
        #
        #      {
        #          "data":[
        #              {
        #                  "id":"5ec36295-5c8d-4874-8d66-2609d4938557",
        #                  "price":"4050.06","size":"0.0044",
        #                  "market_name":"ETH-USDT",
        #                  "side":"sell",
        #                  "created_at":"2021-12-07T17:47:36.811000Z"
        #              },
        #          ]
        #      }
        #
        data = self.safe_value(response, 'data', [])
        return self.parse_orders(data, market)

    def fetch_trades(self, symbol: str, since: Optional[int] = None, limit: Optional[int] = None, params={}):
        """
        get the list of most recent trades for a particular symbol
        :param str symbol: unified symbol of the market to fetch trades for
        :param int|None since: timestamp in ms of the earliest trade to fetch
        :param int|None limit: the maximum amount of trades to fetch
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns [dict]: a list of `trade structures <https://docs.ccxt.com/en/latest/manual.html?#public-trades>`
        """
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['symbol'],
        }
        request['limit'] = limit if (limit is not None) else 100
        request['offset'] = params['offset'] if (params['offset'] is not None) else 0
        response = self.publicGetTradesRecent(self.extend(request, params))
        #
        #      {
        #          "data": [
        #              {
        #                  "id": "0718d520-c796-4061-a16b-915cd13f20c6",
        #                  "price": "0.00000358",
        #                  "size": "50.0",
        #                  "market_name": "DOGE-BTC",
        #                  "order_id": "ff2616d8-58d4-40fd-87ae-937c73eb6f1c",
        #                  "side": "buy",
        #                  "fee': "0.00000036",
        #                  "fee_currency_code": "btc",
        #                  "liquidity": "T",
        #                  "created_at": "2021-12-08T18:26:33.840000Z"
        #              },
        #          ]
        #      }
        #
        data = self.safe_value(response, 'data', [])
        return self.parse_trades(data, market, 1, 1)

    def fetch_trading_fees(self, params={}):
        """
        fetch the trading fees for multiple markets
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns dict: a dictionary of `fee structures <https://docs.ccxt.com/en/latest/manual.html#fee-structure>` indexed by market symbols
        """
        self.load_markets()
        response = self.privateGetUserFees(params)
        #
        #    {
        #        data: {
        #            maker_fee: '0.0',
        #            taker_fee: '0.2',
        #            btc_volume_30d: '0.0'
        #        }
        #    }
        #
        data = self.safe_value(response, 'data', {})
        makerString = self.safe_string(data, 'maker_fee')
        takerString = self.safe_string(data, 'taker_fee')
        maker = self.parse_number(Precise.string_div(makerString, '100'))
        taker = self.parse_number(Precise.string_div(takerString, '100'))
        result = {}
        for i in range(0, len(self.symbols)):
            symbol = self.symbols[i]
            result[symbol] = {
                'info': response,
                'symbol': symbol,
                'maker': maker,
                'taker': taker,
                'percentage': True,
                'tierBased': True,
            }
        return result

    def parse_balance(self, response):
        result = {'info': response}
        balances = self.safe_value(response, 'data', [])
        for i in range(0, len(balances)):
            balance = balances[i]
            currencyId = self.safe_string(balance, 'currency')
            code = self.safe_currency_code(currencyId)
            account = self.account()
            account['token'] = self.safe_string(balance, 'contract')
            account['free'] = self.safe_string(balance, 'amount')
            account['total'] = self.safe_string(balance, 'amount')
            result[code] = account
        return self.safe_balance(result)

    def fetch_balance(self, params={}):
        """
        query for balance and get the amount of funds available for trading or funds locked in orders
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns dict: a `balance structure <https://docs.ccxt.com/en/latest/manual.html?#balance-structure>`
        """
        self.load_markets()
        if params['account'] is None:
            raise ArgumentsRequired(self.id + ' fetchOrders() requires a account argument in params')
        request = {
            'account': params['account'],
        }
        response = self.publicGetAccountBalances(self.extend(request, params))
        return self.parse_balance(response)

    def parse_deposit_address(self, depositAddress, currency=None):
        #
        #     {
        #         "address":"0x77b5051f97efa9cc52c9ad5b023a53fc15c200d3",
        #         "tag":"0"
        #     }
        #
        address = self.safe_string(depositAddress, 'address')
        tag = self.safe_string(depositAddress, 'tag')
        self.check_address(address)
        return {
            'currency': self.safe_currency_code(None, currency),
            'address': address,
            'tag': tag,
            'network': None,
            'info': depositAddress,
        }

    def parse_order_status(self, status):
        statuses = {
            'fulfilled': 'closed',
            'canceled': 'canceled',
            'pending': 'open',
            'open': 'open',
            'partially_filled': 'open',
        }
        return self.safe_string(statuses, status, status)

    def parse_order(self, order, market=None):
        #
        #     {
        #         "id":"8bdd79f4-8414-40a2-90c3-e9f4d6d1eef4"
        #         "market":"IOT-BTC"
        #         "price":"0.0000003"
        #         "size":"4.0"
        #         "size_filled":"3.0"
        #         "fee":"0.0075"
        #         "fee_currency_code":"iot"
        #         "funds":"0.0"
        #         "status":"canceled"
        #         "order_type":"buy"
        #         "post_only":false
        #         "operation_type":"market_order"
        #         "created_at":"2018-01-12T21:14:06.747828Z"
        #     }
        #
        marketId = self.safe_string(order, 'market')
        market = self.safe_market(marketId, market, '-')
        timestamp = self.parse8601(self.safe_string(order, 'block_time'))
        priceString = self.safe_string(order, 'price')
        amountString = self.safe_string(order, 'quantity_init')
        remainingString = self.safe_string(order, 'quantity_curr')
        status = self.parse_order_status(self.safe_string(order, 'status'))
        type = self.safe_string(order, 'order_type')
        if type is not None:
            parts = type.split('_')
            type = parts[0]
        side = self.safe_string(order, 'order_side')
        currency = market.quote if (side == '2') else market.base
        fee = {
            'cost': self.safe_string(market, 'maker'),
            'currency': currency,
        }
        market['inverse'] = True
        return self.safe_order({
            'id': self.safe_string(order, 'order_id'),
            'clientOrderId': self.safe_string(order, 'ordinal_order_id'),
            'datetime': self.iso8601(timestamp),
            'timestamp': timestamp,
            'status': status,
            'symbol': market['symbol'],
            'type': type,
            'side': side,
            'price': priceString,
            'stopPrice': self.safe_string(order, 'trigger_price'),
            'cost': None,
            'amount': amountString,
            'remaining': remainingString,
            'fee': fee,
        }, market)

    def fetch_order(self, id: str, symbol: Optional[str] = None, params={}):
        """
        fetches information on an order made by the user
        :param str|None symbol: unified symbol of the market the order was made in
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns dict: An `order structure <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        self.load_markets()
        orderId = 0
        ordinalID = None
        if len(id) > 15:
            ordinalID = id
        else:
            orderId = int(id)
        request = {}
        request['order_id'] = orderId
        request['ordinal_order_id'] = ordinalID
        response = self.publicGetOrdersLifecycle(self.extend(request, params))
        data = self.safe_value(response, 'data', {})
        return self.parse_order(data[0])

    def fetch_order_trades(self, id: str, symbol: Optional[str] = None, since: Optional[int] = None, limit: Optional[int] = None, params={}):
        """
        fetch the trade
        :param str id: order id
        :param str|None symbol: unified market symbol
        :param int|None since: the earliest time in ms to fetch trades for
        :param int|None limit: the maximum number of trades to retrieve
        :param dict params: extra parameters specific to the poloniex api endpoint
        :returns [dict]: a list of `trade structures <https://docs.ccxt.com/#/?id=trade-structure>`
        """
        self.load_markets()
        if params['account'] is None:
            raise ArgumentsRequired(self.id + ' fetchOrderTrades() requires a account argument in params')
        market = self.market(symbol)
        request = {
            'account': params['account'],
            'symbol': market['symbol'],
            'ordinal_order_ids': [id],
        }
        response = self.publicGetTradesHistory(self.extend(request, params))
        #
        #     [
        #         {
        #             "block_num": "215336694",
        #             "block_time": "2023-09-21T17:54:49.500Z",
        #             "trade_id": "3892445",
        #             "market_id": "1",
        #             "price": "0.000612",
        #             "bid_user": "metallicus",
        #             "bid_user_order_id": "7259690",
        #             "bid_user_ordinal_order_id": 719415c560eab4854d581ca710634669689676518841983011f7721498e85154,
        #             "bid_total": 1764.7058,
        #             "bid_amount": 1762.9411,
        #             "bid_fee": 1.7647,
        #             "bid_referrer": "",
        #             "bid_referrer_fee": 0,
        #             "ask_user": "otctest",
        #             "ask_user_order_id": "7259952",
        #             "ask_user_ordinal_order_id": 1a13fd86ddc3facb2c87bbfb39ce243bebe2c20cf1963ddbcf2a12f05aa44572,
        #             "ask_total": 1.08,
        #             "ask_amount": 1.08,
        #             "ask_fee": 0,
        #             "ask_referrer": "",
        #             "ask_referrer_fee": 0,
        #             "order_side": 1,
        #             "trx_id": 8e135c1e82176d8780c5ef9cbef31a7051dcb0b157b9011e18597770d09c7cee,
        #         }
        #     ]
        #
        data = self.safe_value(response, 'data', [])
        return self.parse_trades(data, market, 1, 1, {'account': params['account']})

    def fetch_open_orders(self, symbol: Optional[str] = None, since: Optional[int] = None, limit: Optional[int] = None, params={}):
        """
        fetch all unfilled currently open orders
        fetch all unfilled currently open orders
        :param str|None symbol: unified market symbol
        :param int|None since: the earliest time in ms to fetch open orders for
        :param int|None limit: the maximum number of  open orders structures to retrieve
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns [dict]: a list of `order structures <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        self.load_markets()
        market = self.market(symbol)
        if params['account'] is None:
            raise ArgumentsRequired(self.id + ' fetchOrders() requires a account argument in params')
        request = {
            'account': params['account'],
            'symbol': market['symbol'],
        }
        request['offset'] = params['offset'] if (params['offset'] is not None) else 0
        request['limit'] = limit if (limit is not None) else 100
        if params['ordinal_order_ids'] is not None:
            request['ordinal_order_ids'] = params['ordinal_order_ids']
        response = self.publicGetOrdersOpen(self.extend(request, params))
        data = self.safe_value(response, 'data', [])
        return self.parse_orders(data, market)

    def fetch_deposits(self, code=None, since=None, limit=None, params={}):
        """
        fetch all deposits made to an account
        :param str|None code: unified currency code
        :param int|None since: the earliest time in ms to fetch deposits for
        :param int|None limit: the maximum number of deposits structures to retrieve
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns [dict]: a list of `transaction structures <https://docs.ccxt.com/en/latest/manual.html#transaction-structure>`
        """
        self.load_markets()
        request = {
            # currency: 'xrp',  # optional: currency code in lowercase
            # status: 'completed',  # optional: withdrawal status
            # since_time  # datetime in ISO8601 format(2017-11-06T09:53:08.383210Z)
            # end_time  # datetime in ISO8601 format(2017-11-06T09:53:08.383210Z)
            # start_time  # datetime in ISO8601 format(2017-11-06T09:53:08.383210Z)
        }
        currency = None
        if code is not None:
            currency = self.currency(code)
            request['currency'] = self.safe_string_lower(currency, 'id')
        if since is not None:
            request['since_time'] = self.iso8601(since)
        response = self.privateGetAccountDeposits(self.extend(request, params))
        #
        #     data: [
        #         {
        #             id: '6e2f18b5-f80e-xxx-xxx-xxx',
        #             amount: '0.1',
        #             status: 'completed',
        #             currency_code: 'eth',
        #             txid: '0xxxx',
        #             address: '0xxxx',
        #             tag: null,
        #             type: 'deposit'
        #         },
        #     ]
        #
        transactions = self.safe_value(response, 'data', [])
        transactions.reverse()  # no timestamp but in reversed order
        return self.parse_transactions(transactions, currency, None, limit)

    def fetch_withdrawals(self, code=None, since=None, limit=None, params={}):
        """
        fetch all withdrawals made from an account
        :param str|None code: unified currency code
        :param int|None since: the earliest time in ms to fetch withdrawals for
        :param int|None limit: the maximum number of withdrawals structures to retrieve
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns [dict]: a list of `transaction structures <https://docs.ccxt.com/en/latest/manual.html#transaction-structure>`
        """
        self.load_markets()
        request = {
            # currency: 'xrp',  # optional: currency code in lowercase
            # status: 'completed',  # optional: withdrawal status
            # since_time  # datetime in ISO8601 format(2017-11-06T09:53:08.383210Z)
            # end_time  # datetime in ISO8601 format(2017-11-06T09:53:08.383210Z)
            # start_time  # datetime in ISO8601 format(2017-11-06T09:53:08.383210Z)
        }
        currency = None
        if code is not None:
            currency = self.currency(code)
            request['currency'] = self.safe_string_lower(currency, 'id')
        if since is not None:
            request['since_time'] = self.iso8601(since)
        response = self.privateGetAccountWithdrawals(self.extend(request, params))
        #
        #     data: [
        #         {
        #             id: '25f6f144-3666-xxx-xxx-xxx',
        #             amount: '0.01',
        #             status: 'completed',
        #             fee: '0.0005',
        #             currency_code: 'btc',
        #             txid: '4xxx',
        #             address: 'bc1xxx',
        #             tag: null,
        #             type: 'withdraw'
        #         },
        #     ]
        #
        transactions = self.safe_value(response, 'data', [])
        transactions.reverse()  # no timestamp but in reversed order
        return self.parse_transactions(transactions, currency, None, limit)

    def parse_transaction_status(self, status):
        statuses = {
            'completed': 'ok',
            'denied': 'failed',
            'approval_pending': 'pending',
        }
        return self.safe_string(statuses, status, status)

    def parse_transaction(self, transaction, currency=None):
        #
        # fetchWithdrawals, withdraw
        #
        #     {
        #         id: '25f6f144-3666-xxx-xxx-xxx',
        #         amount: '0.01',
        #         status: 'completed',
        #         fee: '0.0005',
        #         currency_code: 'btc',
        #         txid: '4xxx',
        #         address: 'bc1xxx',
        #         tag: null,
        #         type: 'withdraw'
        #     },
        #
        # fetchDeposits
        #
        #     {
        #         id: '6e2f18b5-f80e-xxx-xxx-xxx',
        #         amount: '0.1',
        #         status: 'completed',
        #         currency_code: 'eth',
        #         txid: '0xxxx',
        #         address: '0xxxx',
        #         tag: null,
        #         type: 'deposit'
        #     },
        #
        id = self.safe_string(transaction, 'id')
        address = self.safe_string(transaction, 'address')
        tag = self.safe_string(transaction, 'tag')
        txid = self.safe_string(transaction, 'txid')
        currencyId = self.safe_string(transaction, 'currency_code')
        code = self.safe_currency_code(currencyId, currency)
        type = self.safe_string(transaction, 'type')
        if type == 'withdraw':
            type = 'withdrawal'
        status = self.parse_transaction_status(self.safe_string(transaction, 'status'))
        amountString = self.safe_string(transaction, 'amount')
        amount = self.parse_number(amountString)
        feeCostString = self.safe_string(transaction, 'fee')
        feeCost = 0
        if feeCostString is not None:
            feeCost = self.parse_number(feeCostString)
        return {
            'info': transaction,
            'id': id,
            'txid': txid,
            'timestamp': None,
            'datetime': None,
            'network': None,
            'address': address,
            'addressTo': None,
            'addressFrom': None,
            'tag': tag,
            'tagTo': None,
            'tagFrom': None,
            'type': type,
            'amount': amount,
            'currency': code,
            'status': status,
            'updated': None,
            'fee': {
                'currency': code,
                'cost': feeCost,
            },
        }

    def nonce(self):
        return self.milliseconds()

    def fetch_status_sync(self, params={}):
        """
        fetch synchronization time
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns dict: a `balance structure <https://docs.ccxt.com/en/latest/manual.html?#balance-structure>`
        """
        response = self.publicGetStatusSync()
        #
        #     [
        #         {
        #           "dbSecondsBehind": 0,
        #           "chronicleSecondsBehind": 0,
        #           "maxSecondsBehind": 0
        #         }
        #     ]
        return response

    def fetch_ohlcv(self, symbol: str, timeframe='1W', since: Optional[int] = None, limit: Optional[int] = None, params={}):
        """
        retrive ohlcv charts
        :param int timeframe: duration of the input
        :param str symbol: unified market symbol
        :param timestamp from_time: start date and time
        :param timestamp to_time: end date and time
        :param integer|None limit: count to fetch
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns [[int]]: A list of candles ordered, open, high, low, close, volume
        """
        self.load_markets()
        market = self.market(symbol)
        request = {
            'interval': timeframe,
            'symbol': market['symbol'],
        }
        currentTimestamp = self.milliseconds()
        oneMonth = 30 * 24 * 60 * 60 * 1000
        if params['from_time'] is not None:
            request['from'] = self.ymdhms(self.parse_date(params['from_time']))
        else:
            startTime = currentTimestamp - oneMonth
            request['from'] = self.ymdhms(startTime)
        if params['to_time'] is not None:
            request['to'] = self.ymdhms(self.parse_date(params['to_time']))
        else:
            request['to'] = self.ymdhms(currentTimestamp)
        request['limit'] = limit if (limit is not None) else 100
        response = self.publicGetChartOhlcv(self.extend(request, params))
        #
        #   [
        #      {
        #           'close': '0.76',
        #           'count': '0',
        #           'high': '0.76',
        #           'low': '0.76',
        #           'open': '0.76',
        #           'time': '1665950400000',
        #           'volume': '0',
        #           'volume_bid': '0'
        #       }
        #   ]
        transResults = self.safe_value(response, 'data', [])
        results = []
        for i in range(0, len(transResults)):
            results.append(self.parse_ohlcv(transResults[i], market))
        return transResults

    def digest_suffix_ripemd160(self, data, suffix: str):
        d = Uint8Array(len(data) + len(suffix))
        for i in range(0, len(data)):
            d[i] = data[i]
        for i in range(0, len(suffix)):
            len = len(data) + i
            d[len] = suffix.charCodeAt(i)
        return ripemd160(d)

    def key_to_string(self, keyData, suffix: str, prefix: str):
        digest = Uint8Array(self.digest_suffix_ripemd160(keyData, suffix))
        whole = Uint8Array(len(keyData) + 4)
        for i in range(0, len(keyData)):
            whole[i] = keyData[i]
        for i in range(0, 4):
            whole[i + len(keyData)] = digest[i]
        return prefix + self.binary_to_base58(whole)

    def string_to_key(self, s: str, size: float, suffix: str):
        whole = self.base58_to_binary(s)
        data = Uint8Array(whole.buffer, 0, len(whole) - 4)
        digest = Uint8Array(self.digest_suffix_ripemd160(data, suffix))
        digestStatus = (digest[0] != whole[(len(whole)) - 4] or digest[1] != whole[(len(whole)) - 3]
                             or digest[2] != whole[(len(whole)) - 2] or digest[3] != whole[(len(whole)) - 1])
        if digestStatus:
            raise Error("checksum doesn't match")
        return data

    def from_elliptic(self, ellipticSig):
        ellipticSig.recovery = ellipticSig.recovery or 0
        r = numberToBytesBE(ellipticSig.r, 32)
        s = numberToBytesBE(ellipticSig.s, 32)
        eosioRecoveryParam = 0
        eosioRecoveryParam = ellipticSig.recovery + 27
        if ellipticSig.recovery <= 3:
            eosioRecoveryParam += 4
        initParams = Uint8Array([eosioRecoveryParam])
        sigData = concatBytes(initParams, r, s)
        return self.key_to_string(sigData, 'K1', 'SIG_K1_')

    def get_signatures(self, transHex):
        chainID = '384da888112027f0321850a169f737c33e53b388aad48b5adace4bab97f437e0'
        sandboxMode = self.safe_value(self.options, 'sandboxMode', False)
        if sandboxMode:
            chainID = '71ee83bcf52142d61019d95f9cc5427ba6a0d7ff8accd9e2088ae2abeaf3d3dd'
        e = secp256k1
        signatures = []
        initData = Uint8Array(32)
        signBuf = concatBytes(hexToBytes(chainID), transHex, initData)
        digest = e.CURVE.hash(signBuf)
        arrayData = None
        if self.secret.substr(0, 7) == 'PVT_K1_':
            arrayData = self.string_to_key(self.secret.substr(7), 32, 'K1')
        else:
            whole = self.base58_to_binary(self.secret)
            keyData = Uint8Array(32)
            for i in range(0, 32):
                keyData[i] = whole[i + 1]
            arrayData = keyData
        rawSignature = e.sign(digest, arrayData)
        signature = self.from_elliptic(rawSignature)
        signatures.append(signature)
        return signatures

    def set_sandbox_mode(self, enable):
        super(protondex, self).set_sandbox_mode(enable)
        self.options['sandboxMode'] = enable

    def create_order(self, symbol: str, type, side: OrderSide, amount, price=None, params={}):
        """
        create a trade order
        see https://api-docs.protondex.com/reference/orderscontroller_submitorder
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much of currency you want to trade in units of base currency
        :param float|None price: the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        self.load_markets()
        if self.secret is None:
            raise ArgumentsRequired('createOrder call requires a secret to be set')
        market = self.market(symbol)
        marketid = int(market.info.market_id)
        accountName = self.safe_string(params, 'account')
        orderType = int(type)
        orderSide = int(side)
        orderFillType = self.safe_value(params, 'filltype')
        orderAmount = amount
        triggerPrice = (self.safe_value(params, 'triggerprice') is not self.safe_value(params, 'triggerprice') if None) else 0
        referrerName = params['referrer'] if (params['referrer'] is not None) else ''
        bidTokenPrecision = self.parse_to_int(market.info.bid_token.precision)
        askTokenPrecision = self.parse_to_int(market.info.ask_token.precision)
        bidTokenCode = str(market.info.bid_token.code)
        askTokenCode = str(market.info.ask_token.code)
        bidTokenContract = str(market.info.bid_token.contract)
        askTokenContract = str(market.info.ask_token.contract)
        quantityText = format((orderAmount, '.' + str(bidTokenPrecision) + 'f') + ' ' + bidTokenCode) if (orderSide == 2) else format((orderAmount, '.' + str(askTokenPrecision) + 'f') + ' ' + askTokenCode)
        tokenContract = orderSide == bidTokenContract if 2 else askTokenContract
        bidTotal = (orderAmount * math.pow(10, format(bidTokenPrecision)), '.0f')
        askTotal = (orderAmount * math.pow(10, format(askTokenPrecision)), '.0f')
        quantity = str(bidTotal) if (orderSide == 2) else str(askTotal)
        orderPrice = Number(price) * Number(math.pow(10, format(askTokenPrecision), '.0f'))
        if (orderSide == 2 and orderFillType == 1 and price == 1) or (orderSide == 1 and orderFillType == 1 and price == '9223372036854775806'):
            orderPrice = price
        auth = {'actor': accountName, 'permission': 'active'}
        action1 = {
            'account': tokenContract,
            'name': 'transfer',
            'data': {
                'from': accountName,
                'to': 'dex',
                'quantity': quantityText,
                'memo': '',
            },
            'authorization': [auth],
        }
        action2 = {
            'account': 'dex',
            'name': 'placeorder',
            'data': {
                'market_id': marketid,
                'account': accountName,
                'order_type': orderType,
                'order_side': orderSide,
                'fill_type': orderFillType,
                'bid_symbol': {
                    'sym': bidTokenPrecision + ',' + bidTokenCode,
                    'contract': bidTokenContract,
                },
                'ask_symbol': {
                    'sym': askTokenPrecision + ',' + askTokenCode,
                    'contract': askTokenContract,
                },
                'referrer': referrerName,
                'quantity': quantity,
                'price': orderPrice,
                'trigger_price': triggerPrice,
            },
            'authorization': [auth],
        }
        action3 = {
            'account': 'dex',
            'name': 'process',
            'data': {
                'q_size': 20,
                'show_error_msg': 0,
            },
            'authorization': [auth],
        }
        actions = [action1, action2, action3]
        request = {
            'transaction': {actions},
        }
        orderDetails = []
        retries = 10
        while(retries > 0):
            try:
                serResponse = self.publicPostOrdersSerialize(self.extend(request))
                result = self.safe_value(serResponse, 'data', [])
                tx = hexToBytes(result['serialized_tx_hex'])
                signatures = self.get_signatures(tx)
                orderRequest = {
                    'serialized_tx_hex': str(result['serialized_tx_hex']),
                    'signatures': signatures,
                }
                response = self.publicPostOrdersSubmit(self.extend(orderRequest))
                data = self.safe_value(response, 'data', [])
                # Response format
                # {
                #     trx_id: 'd6124ed37ba30f499ec3043c185d6e458c7f4a581e09a4f3cefe64c723426af0',
                #     block_time: '2023-06-16T19:10:30.000Z',
                #     orders: [
                #         {
                #             ordinal_order_id: '378b28d5164be48adc7c0c7c02a9803abc4109185f11cc6116864e94878ff5cc',
                #             order_id: '3990837',
                #             status: 'create'
                #         }
                #     ]
                # }
                orderDetails['ordinal_order_id'] = data.orders[0].ordinal_order_id
                orderDetails['order_id'] = data.orders[0].order_id
                orderDetails['status'] = data.orders[0].status
                orderDetails['block_time'] = data['block_time']
                orderDetails['symbol'] = symbol
                orderDetails['order_type'] = orderType
                orderDetails['order_side'] = orderSide
                orderDetails['price'] = orderPrice
                orderDetails['trigger_price'] = triggerPrice
                retries = 0
            except Exception as e:
                if self.last_json_response:
                    message = self.safe_string(self.last_json_response.error.details[0], 'message')
                    if message == 'is_canonical( c ): signature is not canonical':
                        --retries
                    else:
                        if message == 'assertion failure with message: overdrawn balance':
                            raise InsufficientFunds('- Add funds to the account')
                        retries = 0
                if not retries:
                    raise e
        return self.parse_order(orderDetails, market)

    def cancel_order(self, id: str, symbol: Optional[str] = None, params={}):
        """
        cancels an open order
        :param str id: order id
        :param str|None symbol: unified symbol of the market the order was made in
        :param dict params: extra parameters specific to the protondex api endpoint
        :returns dict: An `order structure <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        self.load_markets()
        if self.secret is None:
            raise ArgumentsRequired('cancelOrder call requires a secret to be set')
        orderId = int(id)
        accountName = self.safe_string(params, 'account')
        auth = {'actor': accountName, 'permission': 'active'}
        action1 = {
            'account': 'dex',
            'name': 'cancelorder',
            'data': {
                'account': accountName,
                'order_id': orderId,
            },
            'authorization': [auth],
        }
        action2 = {
            'account': 'dex',
            'name': 'withdrawall',
            'data': {
                'account': accountName,
            },
            'authorization': [auth],
        }
        actions = [action1, action2]
        request = {
            'transaction': {actions},
        }
        data = None
        retries = 10
        while(retries > 0):
            try:
                serResponse = self.publicPostOrdersSerialize(self.extend(request))
                result = self.safe_value(serResponse, 'data', [])
                tx = hexToBytes(result['serialized_tx_hex'])
                signatures = self.get_signatures(tx)
                orderRequest = {
                    'serialized_tx_hex': str(result['serialized_tx_hex']),
                    'signatures': signatures,
                }
                response = self.publicPostOrdersSubmit(self.extend(orderRequest))
                data = self.safe_value(response, 'data', [])
                retries = 0
            except Exception as e:
                if self.last_json_response:
                    message = self.safe_string(self.last_json_response.error.details[0], 'message')
                    if message == 'is_canonical( c ): signature is not canonical':
                        --retries
                    else:
                        retries = 0
                if not retries:
                    raise e
        return data

    def getorder_ids(self, name: str, symbol: str):
        try:
            cancelList = []
            i = 0
            while(i > 5):
                ordersList = self.fetch_open_orders(symbol, 1, 100, {'account': name, 'offset': 100 * i, 'ordinal_order_ids': ''})
                if not len(ordersList):
                    break
                for j in range(0, len(ordersList)):
                    cancelList.append(ordersList[j]['id'])
                ++i
            return cancelList
        except Exception as e:
            raise OrderNotFound(' calcelAllOrders() error: order not found')

    def cancel_all_orders(self, symbol=None, params={}):
        """
        cancel all open orders
        :param str|None symbol: unified market symbol, only orders in the market of self symbol are cancelled when symbol is not None
        :param dict params: extra parameters specific to the bittrex api endpoint
        :returns [dict]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        self.load_markets()
        market = self.market(symbol)
        if self.secret is None:
            raise ArgumentsRequired('cancelOrder call requires a secret to be set')
        accountName = self.safe_string(params, 'account')
        orderList = self.getorder_ids(accountName, market['symbol'])
        if not len(orderList):
            raise OrderNotFound(' calcelAllOrders() error: no orders found')
        actions = []
        auth = {'actor': accountName, 'permission': 'active'}
        for i in range(0, len(orderList)):
            action = {
                'account': 'dex',
                'name': 'cancelorder',
                'data': {
                    'account': accountName,
                    'order_id': orderList[i],
                },
                'authorization': [auth],
            }
            actions.append(action)
        withdrawAction = {
            'account': 'dex',
            'name': 'withdrawall',
            'data': {
                'account': accountName,
            },
            'authorization': [auth],
        }
        actions.append(withdrawAction)
        request = {
            'transaction': {actions},
        }
        data = None
        retries = 10
        while(retries > 0):
            try:
                serResponse = self.publicPostOrdersSerialize(self.extend(request))
                result = self.safe_value(serResponse, 'data', [])
                tx = hexToBytes(result['serialized_tx_hex'])
                signatures = self.get_signatures(tx)
                orderRequest = {
                    'serialized_tx_hex': str(result['serialized_tx_hex']),
                    'signatures': signatures,
                }
                response = self.publicPostOrdersSubmit(self.extend(orderRequest))
                data = self.safe_value(response, 'data', [])
                retries = 0
            except Exception as e:
                if self.last_json_response:
                    message = self.safe_string(self.last_json_response.error.details[0], 'message')
                    if message == 'is_canonical( c ): signature is not canonical':
                        --retries
                    else:
                        retries = 0
                if not retries:
                    raise e
        return data

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        url = self.urls['api']['rest']
        request = '/' + self.version + '/' + self.implode_params(path, params)
        query = self.omit(params, self.extract_params(path))
        implodedPath = self.implode_params(path, params)
        if api == 'public':
            if (method == 'POST') or (method == 'PUT') or (method == 'DELETE'):
                if query:
                    body = self.json(query)
                headers = {
                    'Content-Type': 'application/json',
                }
            elif query:
                request += '?' + self.urlencode(query)
        else:
            self.check_required_credentials()
            timestamp = str(self.nonce())
            auth = method + "\n"  # eslint-disable-line quotes
            url += '/' + implodedPath
            auth += '/' + implodedPath
            if (method == 'POST') or (method == 'PUT') or (method == 'DELETE'):
                auth += "\n"  # eslint-disable-line quotes
                if query:
                    body = self.json(query)
                    auth += 'requestBody=' + body + '&'
                auth += 'signTimestamp=' + timestamp
            else:
                sortedQuery = self.extend({'signTimestamp': timestamp}, query)
                sortedQuery = self.keysort(sortedQuery)
                auth += "\n" + self.urlencode(sortedQuery)  # eslint-disable-line quotes
                if query:
                    url += '?' + self.urlencode(query)
            signature = self.hmac(self.encode(auth), self.encode(self.secret), hashlib.sha256, 'base64')
            headers = {
                'Content-Type': 'application/json',
                'key': self.apiKey,
                'signTimestamp': timestamp,
                'signature': signature,
            }
        url = url + request
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, code, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if not response:
            return  # fallback to default error handler
        error = self.safe_value(response, 'error')
        if error is not None:
            errorCode = self.safe_string(error, 'code')
            feedback = self.id + ' ' + body
            self.throw_exactly_matched_exception(self.exceptions, errorCode, feedback)
            raise ExchangeError(feedback)  # unknown message
